#
#    This file is part of TuneMPC.
#
#    TuneMPC -- A Tool for Economic Tuning of Tracking (N)MPC Problems.
#    Copyright (C) 2020 Jochem De Schutter, Mario Zanon, Moritz Diehl (ALU Freiburg).
#
#    TuneMPC is free software; you can redistribute it and/or
#    modify it under the terms of the GNU Lesser General Public
#    License as published by the Free Software Foundation; either
#    version 3 of the License, or (at your option) any later version.
#
#    TuneMPC is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public
#    License along with TuneMPC; if not, write to the Free Software Foundation,
#    Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
#
#!/usr/bin/python3
""" Example of a periodic, single-aircraft drag-mode airborne wind energy system.

The user inputs are generated by the file "prepare_inputs.py"

Example description found in:

TuneMPC - A Tool for Economic Tuning of Tracking (N)MPC Problems
J. De Schutter, M. Zanon, M. Diehl
(pending approval)

:author: Jochem De Schutter

"""

import matplotlib.pyplot as plt
import tunempc
import tunempc.pmpc as pmpc
import tunempc.preprocessing as preprocessing
import tunempc.closed_loop_tools as clt
import numpy as np
import casadi as ca
import casadi.tools as ct
import pickle

# load user input
with open('user_input.pkl','rb') as f:
    user_input = pickle.load(f)

# set-up tuning problem
tuner = tunempc.Tuner(
    f = user_input['f'],
    l = user_input['l'],
    h = user_input['h'],
    p = user_input['p']
)

# solve OCP
wsol = tuner.solve_ocp(w0 = user_input['w0'])

# convexify stage cost matrices
Hc   = tuner.convexify(solver='mosek')
S    = tuner.S

# set-up open-loop scenario
Nmpc  = 20
alpha_steps = 20

# tether length
l_t = np.sqrt(
    wsol['x',0][0]**2 +
    wsol['x',0][1]**2 +
    wsol['x',0][2]**2
)

# state and control dimensions
sys = tuner.sys
nx = sys['vars']['x'].shape[0]
nu = sys['vars']['u'].shape[0]


# mpc options:
opts = {}
# add projection operator for terminal constraint
opts['p_operator'] = ca.Function(
    'p_operator',
    [sys['vars']['x']],
    [ct.vertcat(sys['vars']['x'][1:3],
    sys['vars']['x'][4:])]
)

# slack active constraints
opts['slack_flag'] = 'active'

# create controllers
ctrls = {}

# # economic MPC
# ctrls['EMPC'] = tuner.create_mpc('economic', Nmpc,opts=opts)

# # standard tracking MPC
# tuningTn = {'H': [np.diag((nx+nu)*[1]+sys['vars']['us'].shape[0]*[0.0])]*user_input['p'], 'q': S['q']}
# ctrls['TMPC-1'] = tuner.create_mpc('tracking', Nmpc, tuning = tuningTn, opts = opts)

# # manually tuned tracking MPC
# Ht2 = [np.diag([0.1,0.1,0.1, 1.0, 1.0, 1.0, 1.0e3, 1.0, 100.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0])]*user_input['p']
# tuningTn2 = {'H': Ht2, 'q': S['q']}
# ctrls['TMPC-2'] = tuner.create_mpc('tracking', Nmpc, tuning = tuningTn2, opts= opts)

# tuned tracking MPC
ctrls['TUNEMPC'] = tuner.create_mpc('tuned', Nmpc, opts = opts)

ACADOS_CODEGENERATE = True
if ACADOS_CODEGENERATE:

    # get system dae
    alg = user_input['dyn']

    # solver options
    opts = {}
    opts['qp_solver'] = 'FULL_CONDENSING_QPOASES' # PARTIAL_CONDENSING_HPIPM
    opts['hessian_approx'] = 'GAUSS_NEWTON'
    opts['integrator_type'] = 'IRK'
    opts['nlp_solver_type'] = 'SQP' # SQP_RTI
    # opts['qp_solver_cond_N'] = Nmpc # ???
    opts['print_level'] = 1
    opts['sim_method_num_steps'] = 50
    opts['tf'] = Nmpc*user_input['ts']
    opts['nlp_solver_max_iter'] = 50
    opts['nlp_solver_step_length'] = 0.9

    acados_ocp_solver, acados_integrator = ctrls['TUNEMPC'].generate(
        alg, opts = opts, name = 'awe_system'
        )

x0 = wsol['x',0]
u0 = ctrls['TUNEMPC'].step_acados(x0)
sol = ctrls['TUNEMPC'].w_sol_acados

# initialize and set-up open-loop simulation
alpha = np.linspace(-1.0, 1.0, alpha_steps+1) # deviation sweep grid
dz = 8 # max. deviation
x0 = wsol['x',0]
tgrid = [1/user_input['p']*i for i in range(Nmpc)]
tgridx = tgrid + [tgrid[-1]+1/user_input['p']]

# optimal stage cost and constraints for comparison
lOpt, hOpt = [], []
for k in range(Nmpc):
    lOpt.append(user_input['l'](wsol['x', k%user_input['p']], wsol['u',k%user_input['p']]).full()[0][0])
    hOpt.append(user_input['h'](wsol['x', k%user_input['p']], wsol['u',k%user_input['p']]).full())

plt.figure(0)
for i in range(nu):
    plt.subplot(nu, 1, i+1)
    if i == 0:
        plt.title('Control prediction deviation')
    # plt.step(tgrid, [ for k in range(Nmpc)], color = 'black', linestyle = '--', where='post')
    plt.step(tgrid, [sol['u',k,i]-wsol['u',k,i] for k in range(Nmpc)], where = 'post')
    plt.hlines(0.0, tgrid[0], tgrid[-1], linestyle ='--')
    plt.grid(True)
    plt.ylabel('Delta u{}'.format(i))
    plt.autoscale(enable=True, axis='x', tight=True)
    plt.legend(['prediction'])

hSol = []
for k in range(Nmpc):
    hSol.append(user_input['h'](sol['x',k], sol['u',k]).full())

nh = hSol[0].shape[0]
ncol = 3
nrow = int(np.ceil(nh/ncol))
fig, axes = plt.subplots(nrow, ncol, sharex = 'col', num=1)
for i in range(nh):
    axes[i//ncol, i%ncol].step(tgrid, [hOpt[k][i] for k in range(Nmpc)], color = 'black', linestyle = '--', where='post')
    axes[i//ncol, i%ncol].step(tgrid, [hSol[k][i] for k in range(Nmpc)])
    axes[i//ncol, i%ncol].grid(True)
    axes[i//ncol, i%ncol].hlines(0.0, tgrid[0], tgrid[-1])
    axes[i//ncol, i%ncol].grid(True)
    axes[i//ncol, i%ncol].set_ylabel('h{}'.format(i))
    axes[i//ncol, i%ncol].autoscale(enable=True, axis='x', tight=True)
    if i == 0:
        axes[k//ncol, k%ncol].legend(['reference', 'prediction'])

plt.figure(2)
for i in range(nx):
    plt.subplot(nx, 1, i+1)
    if i == 0:
        plt.title('State prediction')
    # plt.plot(tgrid, [wsol['x',k,i] for k in range(Nmpc)], color = 'black', linestyle = '--')
    plt.plot(tgrid, [sol['x',k,i]-wsol['x',k,i] for k in range(Nmpc)])
    plt.hlines(0.0, tgrid[0], tgrid[-1], linestyle ='--')
    plt.grid(True)
    plt.ylabel('Delta x{}'.format(i))
    plt.autoscale(enable=True, axis='x', tight=True)
    if i == 0:
        plt.legend(['reference', 'prediction'])
plt.show()
import ipdb; ipdb.set_trace()


# open loop simulation
import copy
log = []
for alph in alpha:
    x_init = copy.deepcopy(x0)
    x_init[2] = x_init[2] + alph*dz
    x_init[0] = np.sqrt(-x_init[2]**2-x_init[1]**2+(l_t)**2)
    x_init[5] = -(x_init[0]*x_init[3] + x_init[1]*x_init[4]) / x_init[2]
    log.append(clt.check_equivalence(ctrls, user_input['l'], user_input['h'], x0, x_init-x0, [1.0])[-1])
    for name in list(ctrls.keys()):
        ctrls[name].reset()


# plotting options
alpha_plot = -1
lw = 2
ctrls_colors = {
    'EMPC': 'blue',
    'TUNEMPC': 'green',
    'TMPC-1': 'red',
    'TMPC-2': 'orange'
}
ctrl_lstyle = {
    'EMPC': 'solid',
    'TUNEMPC': 'dashed',
    'TMPC-1': 'dashdot',
    'TMPC-2': 'dotted'
}
ctrls_markers =  {
    'EMPC': '.',
    'TUNEMPC': 'o',
    'TMPC-1': '^',
    'TMPC-2': 'x'
}

# plot feedback equivalence
plt.figure(1)
for name in list(ctrls.keys()):
    if name != 'EMPC':
        feedback_norm = [
            np.linalg.norm(
                np.divide(
                    np.array(log[k]['u'][name][0]) - np.array(log[k]['u']['EMPC'][0]),
                    np.array(log[0]['u']['EMPC'][0]))
            ) for k in range(len(alpha))]
        plt.plot(
            [dz*alph for alph in alpha],
            feedback_norm,
            marker = ctrls_markers[name],
            color = ctrls_colors[name],
            linestyle = ctrl_lstyle[name],
            markersize=2,
            linewidth=lw
                )
plt.grid(True)
plt.legend(list(ctrls.keys())[1:])
plt.title(r'$\Delta \pi_0^{\star}(\hat{x}_0) \ [-]$')
plt.xlabel(r'$\Delta z \ \mathrm{[m]}$')

# plot stage cost deviation over time
plt.figure(2)
for name in list(ctrls.keys()):
    stage_cost_dev = [x[0] - x[1] for x in zip(log[alpha_plot]['l'][name],lOpt)]
    plt.step(
        tgrid,
        stage_cost_dev,
        color = ctrls_colors[name],
        linestyle = ctrl_lstyle[name],
        linewidth=lw,
        where='post')
plt.legend(list(ctrls.keys()))
plt.grid(True)
plt.xlabel('t - [s]')
plt.title('Stage cost deviation')
plt.autoscale(enable=True, axis='x', tight=True)

# plot state deviation over time
plt.subplots(nx,1,sharex = True)
for i in range(nx):
    plt.subplot(nx,1,i+1)
    if i == 0:
        plt.title('State deviation')
    if i == nx:
        plt.xlabel('t - [s]')

    for name in list(ctrls.keys()):
        plt.plot(
            tgridx,
            [log[alpha_plot]['x'][name][j][i] - wsol['x',j][i] for j in range(Nmpc+1)],
            color = ctrls_colors[name],
            linestyle = ctrl_lstyle[name],
            linewidth=lw)
        plt.plot(tgridx, [0.0 for j in range(Nmpc+1)],  linestyle='--', color='black')
        plt.autoscale(enable=True, axis='x', tight=True)
        plt.grid(True)

# plot transient cost vs. alpha
plt.figure(4)
transient_cost = {}
for name in list(ctrls.keys()):
    transient_cost[name] = []
    for i in range(len(alpha)):
            transient_cost[name].append(
                sum([x[0] - x[1] for x in zip(log[i]['l'][name],lOpt)])
                )
    plt.plot(
        alpha,
        transient_cost[name],
        marker = ctrls_markers[name],
        color = ctrls_colors[name],
        linestyle = ctrl_lstyle[name],
        markersize = 2,
        linewidth=lw)
plt.grid(True)
plt.legend(list(ctrls))
plt.title('Transient cost')
plt.xlabel(r'$\alpha \ \mathrm{[-]}$')

plt.show()